# entity/image.py
from datetime import datetime
from typing import Optional

class Image:
    """
    Image entity representing an uploaded image record
    
    Attributes:
        id: Primary key (auto-generated by database)
        public_id: Cloudinary public ID for the image
        url: Secure URL to access the image
        width: Image width in pixels
        height: Image height in pixels
        format: Image format (jpg, png, gif, etc.)
        file_size: File size in bytes
        folder: Cloudinary folder where image is stored
        original_filename: Original filename when uploaded
        tags: List of tags associated with the image
        created_at: Timestamp when record was created
        updated_at: Timestamp when record was last updated
        is_active: Soft delete flag
    """
    
    def __init__(
        self,
        public_id: str,
        url: str,
        width: Optional[int] = None,
        height: Optional[int] = None,
        format: Optional[str] = None,
        file_size: Optional[int] = None,
        folder: Optional[str] = None,
        original_filename: Optional[str] = None,
        tags: Optional[list] = None,
        id: Optional[int] = None,
        created_at: Optional[datetime] = None,
        updated_at: Optional[datetime] = None,
        is_active: bool = True
    ):
        """
        Initialize Image entity
        
        Args:
            public_id: Cloudinary public ID (required)
            url: Image URL (required)
            width: Image width in pixels
            height: Image height in pixels
            format: Image format (jpg, png, etc.)
            file_size: File size in bytes
            folder: Cloudinary folder path
            original_filename: Original filename
            tags: List of tags for categorization
            id: Database primary key (set by database)
            created_at: Creation timestamp (set by database)
            updated_at: Update timestamp (set by database)
            is_active: Active status for soft deletes
        """
        self.id = id
        self.public_id = public_id
        self.url = url
        self.width = width
        self.height = height
        self.format = format
        self.file_size = file_size
        self.folder = folder
        self.original_filename = original_filename
        self.tags = tags or []
        self.created_at = created_at or datetime.utcnow()
        self.updated_at = updated_at or datetime.utcnow()
        self.is_active = is_active

    def to_dict(self) -> dict:
        """
        Convert entity to dictionary representation
        
        Returns:
            dict: Dictionary representation of the image
        """
        return {
            'id': self.id,
            'public_id': self.public_id,
            'url': self.url,
            'width': self.width,
            'height': self.height,
            'format': self.format,
            'file_size': self.file_size,
            'folder': self.folder,
            'original_filename': self.original_filename,
            'tags': self.tags,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'is_active': self.is_active
        }

    def to_public_dict(self) -> dict:
        """
        Convert entity to public API representation (excluding sensitive fields)
        
        Returns:
            dict: Public dictionary representation
        """
        return {
            'id': self.id,
            'public_id': self.public_id,
            'url': self.url,
            'width': self.width,
            'height': self.height,
            'format': self.format,
            'file_size': self.file_size,
            'tags': self.tags,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }

    @classmethod
    def from_dict(cls, data: dict) -> 'Image':
        """
        Create Image entity from dictionary
        
        Args:
            data: Dictionary containing image data
            
        Returns:
            Image: Image entity instance
        """
        # Handle datetime strings
        created_at = None
        updated_at = None
        
        if data.get('created_at'):
            if isinstance(data['created_at'], str):
                created_at = datetime.fromisoformat(data['created_at'].replace('Z', '+00:00'))
            else:
                created_at = data['created_at']
                
        if data.get('updated_at'):
            if isinstance(data['updated_at'], str):
                updated_at = datetime.fromisoformat(data['updated_at'].replace('Z', '+00:00'))
            else:
                updated_at = data['updated_at']

        return cls(
            id=data.get('id'),
            public_id=data['public_id'],
            url=data['url'],
            width=data.get('width'),
            height=data.get('height'),
            format=data.get('format'),
            file_size=data.get('file_size'),
            folder=data.get('folder'),
            original_filename=data.get('original_filename'),
            tags=data.get('tags', []),
            created_at=created_at,
            updated_at=updated_at,
            is_active=data.get('is_active', True)
        )

    def update_metadata(self, **kwargs) -> None:
        """
        Update image metadata
        
        Args:
            **kwargs: Fields to update
        """
        allowed_fields = {
            'tags', 'original_filename', 'is_active'
        }
        
        for field, value in kwargs.items():
            if field in allowed_fields:
                setattr(self, field, value)
        
        self.updated_at = datetime.utcnow()

    def add_tags(self, new_tags: list) -> None:
        """
        Add tags to the image
        
        Args:
            new_tags: List of tags to add
        """
        if not isinstance(new_tags, list):
            new_tags = [new_tags]
        
        # Add only unique tags
        for tag in new_tags:
            if tag not in self.tags:
                self.tags.append(tag)
        
        self.updated_at = datetime.utcnow()

    def remove_tags(self, tags_to_remove: list) -> None:
        """
        Remove tags from the image
        
        Args:
            tags_to_remove: List of tags to remove
        """
        if not isinstance(tags_to_remove, list):
            tags_to_remove = [tags_to_remove]
        
        self.tags = [tag for tag in self.tags if tag not in tags_to_remove]
        self.updated_at = datetime.utcnow()

    def get_file_size_human_readable(self) -> str:
        """
        Get human-readable file size
        
        Returns:
            str: Human-readable file size (e.g., "2.5 MB")
        """
        if not self.file_size:
            return "Unknown"
        
        for unit in ['B', 'KB', 'MB', 'GB']:
            if self.file_size < 1024.0:
                return f"{self.file_size:.1f} {unit}"
            self.file_size /= 1024.0
        return f"{self.file_size:.1f} TB"

    def get_dimensions_string(self) -> str:
        """
        Get dimensions as string
        
        Returns:
            str: Dimensions string (e.g., "1920x1080")
        """
        if self.width and self.height:
            return f"{self.width}x{self.height}"
        return "Unknown"

    def get_aspect_ratio(self) -> Optional[float]:
        """
        Calculate aspect ratio
        
        Returns:
            float: Aspect ratio (width/height) or None if dimensions unknown
        """
        if self.width and self.height and self.height > 0:
            return round(self.width / self.height, 2)
        return None

    def is_portrait(self) -> bool:
        """Check if image is portrait orientation"""
        if self.width and self.height:
            return self.height > self.width
        return False

    def is_landscape(self) -> bool:
        """Check if image is landscape orientation"""
        if self.width and self.height:
            return self.width > self.height
        return False

    def is_square(self) -> bool:
        """Check if image is square"""
        if self.width and self.height:
            return self.width == self.height
        return False

    def soft_delete(self) -> None:
        """Mark image as deleted (soft delete)"""
        self.is_active = False
        self.updated_at = datetime.utcnow()

    def restore(self) -> None:
        """Restore soft-deleted image"""
        self.is_active = True
        self.updated_at = datetime.utcnow()

    def __repr__(self) -> str:
        """String representation of the Image entity"""
        return f"<Image(id={self.id}, public_id='{self.public_id}', format='{self.format}', dimensions='{self.get_dimensions_string()}')>"

    def __eq__(self, other) -> bool:
        """Check equality based on public_id"""
        if not isinstance(other, Image):
            return False
        return self.public_id == other.public_id

    def __hash__(self) -> int:
        """Hash based on public_id"""
        return hash(self.public_id)